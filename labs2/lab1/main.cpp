#include "myRect.h"
#include "myString.h"
#include <iostream>
#include <cstdarg>
#include <cstddef>

MyString Concatenate(const char* st1, ...)
{
	size_t count = 0;

	va_list p;
	va_start(p, st1);
	const char* tmp = st1;
	while (*tmp != '!')
	{
		while (*tmp != '\0')
		{
			count++;
			tmp++;
		}
		tmp = va_arg(p, const char*);
	} 
	std::cout << "\nargument count = " << count << '\n';
	
	char* result = new char[count + 1];
	char* r = result;

	va_start(p, st1);
	tmp = st1;
	while (*tmp != '!')
	{
		while (*tmp != '\0')
		{
			*r = *tmp;
			tmp++;
			r++;
		}
		tmp = va_arg(p, const char*);
	}
	//r++;
	*r = '\0';
	MyString res(result);
	delete[] result;
	return res;
}

Rect BoundingRect(Rect r1, Rect r2)
{
	Coord tr1 = r1.GetAll();
	Coord tr2 = r2.GetAll();
	Rect res(tr1.x1, tr1.y1, tr2.x2, tr2.y2);
	return res;
}

Rect BoundingRect2(const Rect& r1, const Rect& r2)
{
	Coord tr1 = r1.GetAll();
	Coord tr2 = r2.GetAll();
	int t, b, l, r;
	if (tr1.x1 < tr2.x1) l = tr1.x1; else l = tr2.x1;
	if (tr2.x2 < tr2.x2) r = tr2.x2; else r = tr1.x1;
	if (tr1.y1 < tr2.y1) b = tr1.y1; else b = tr2.y1;
	if (tr1.y2 < tr2.y2) t = tr2.y2; else t = tr1.y2;
	return Rect (l, r, t, b);
}

class Bochka
{
private:
	double volume;
	char* type;
	double concentration;
public:
	double Con() { return concentration; }
	Bochka(double vol, double conc, char* typ) :volume(vol), type(typ), concentration(conc) {};
//	~Bochka() {}
	void Pereliv(Bochka& from)
	{
		this->concentration = (this->concentration * this->volume + 1 * from.concentration) / (1 + this->volume);
		this->volume += 1;
		from.volume -= 1;
	}
};

#define	stop __asm nop

int main()
{
using namespace std;

	//Задание 1.Объявление класса. Создание экземпляра класса.
	//Вызов методов класса. 
	//Откройте закладку Class View - (здесь Вы увидите имена методов и
	//данных - классов Rect и MyString)
	//Обратите внимание на пиктограммы слева от имен членов класса - они
	//обозначают спецификатор доступа к каждому члену класса.

	//Какой конструктор вызывается при создании экземпляра класса? по умолчанию
/*	{
*		Rect rect{};	--по умолчанию без параметров
*		MyString str{};	--по умолчанию без параметров
*		stop
*	}
*/
	//1a. Объявите и определите конструктор с параметрами для
	//инициализации переменных класса. Создайте экземляры класса Rect
	//с помощью конструктора с параметрами. Если компилятор выдает
	//ошибку в предыдущем фрагменте, подумайте - чего ему не
	//хватает? Добейтесь отсутствия ошибок.
	//Выполняя задание с самого начала по шагам, определите:
	//в какой момент происходит вызов конструктора(какого?)?
/*	
*	{
*	Rect rect2( 5, 5, 1, 1 );
*		stop
*	}
*/
	//1б. При конструировании объекта посредством конструктора без параметров
	//предусмотрите инициализацию переменных класса, например, нулем
/*
*{
*	MyString str2;
*	const char* ptr = str2.print();
*	std::cout << *ptr << std::endl;
*	char c;
*	std::cin >> c;
*}
*/
	//1в. Подумайте, как следует поступать в случае, когда пользователь задал
	//координаты следующим образом:

	//Rect rrr(4,3,2,1);
	
//stop
//1г. Объявите, определите и вызовите метод класса InflateRect(), 
//который увеличивает размеры прямоугольника на заданные приращения
//(раздвигая стороны от центра - каждую сторону на свое значение).
//Подсказка: объявить и определить методы можно не только "вручную",
//но и с помощью Wizard-a Class View. Для этого: откройте закладку
//ClassView окна проекта, сделайте активным класс Rect и нажмите
//правую кнопку мыши - в появившемся контекстном меню выберите
//Add/Add Member Function... С помощью появившейся диалоговой панели
//"дайте указания" Wizard-у как объявить и определить метод.
/*
*	{
*	Rect rect{};
*	rect.InflateRect(5, 2);
*	stop
*}
*/

//Задание 2.Перегрузка конструкторов и методов класса.
//Конструктор копирования.

//2а.Объявите и определите конструктор копирования в классе Rect.
//Выполняя задание по шагам, определите, какой
//конструктор вызывается при создании r1,r2,r3 и r4?
//Чему равны переменные созданных объектов?
/*
		Rect r1;
		Rect r2(1,2,3,4);
		Rect r3 = r1;
		Rect r4(r2);
		stop


//2б. Объявите и определите в классе Rect метод InflateRect(),
  //который принимает два аргумента, по умолчанию равных 1, и 
  //раздвигает стороны прямоугольника на заданные приращения.
  //Для каких объектов вызывается функция InflateRect()?

		r1.InflateRect(1,1);
		r2.InflateRect(2,2);
	//Какая из функций InflateRect() вызывается в каждом из трех случаев?
		r3.InflateRect(2,2,2,2);
		r3.InflateRect(3,3);
		r3.InflateRect(5);	//это ф-я с 2-мя аргументами, у которой один аргумент = 5, а второй по умолчанию
		r3.InflateRect();	//у которой два аргумента по умолчанию
	stop
*/

//Задание 3.Спецификаторы доступа. Инкапсуляция. 
/*
*{
*	Rect r;
*	//Раскомментируйте следующую строку. Объясните ошибку
*	//компилятора
*
//	int tmp = r.m_left;	попытка доступа к закрытому члену класса
*
*
*
*	//Введите в класс Rect метод void SetAll(...),
*	//который присваивают переменным класса передаваемые
*	//значения. Вызовите созданный метод, проверьте корректность.
*		{
*			r.SetAll(1, 2, 3, 4);
*		}
*
*	//Введите в класс Rect парный метод GetAll(...),
*	//который "достает" значения private-переменных класса.
*	//Вызовите созданный метод, проверьте корректность.
*		r.GetAll();
*	stop
*	}
*/

//Задание 4.Передача экземпляра класса в качестве параметра
//функции. Возвращение объекта класса по значению. Поставив
//остановы в конструкторе копирования или выполняя фрагмент
//по шагам, определите: в какой момент происходит обращение
//к конструктору копирования. 
//Создайте глобальную функцию 
// Rect BoundingRect(Rect, Rect);
//которая принимает два объекта класса Rect по значению и
//возвращает объект класса Rect, который является прямоугольником,
//в который вписаны заданные прямоугольники. Как происходит
//передача параметров и возвращение объекта класса?

	//Замечание*: хорошо было бы учесть тот факт, что прямоугольник
	//может оказаться "ненормализованным", то есть m_left>m_right или/и
	//m_top>m_bottom
/*
	{

		Rect r1(1,2,3,4), r2(5,6,7,8),r3; // два 4-х точечных конструктора и один дефалт
	r3= BoundingRect(r1, r2);	//конструкторы копирования
	stop

	//Задание 4а. Передача объектов по ссылке.
	//Создайте глобальную функцию BoundingRect2, которая выполняет ту же
	//задачу, принимая параметры по ссылке
	//Вызываются ли конструкторы при передаче параметров?

		r3 = BoundingRect2(r1, r2);
	stop
	}
*/

	//Задание 5. Указатель на класс. Объявите и определите
	//явный деструктор класса. Поставьте остановы в 
	//конструкторе (конструкторах) и деструкторе. Определите: когда для
	//каждого из объектов вызывается конструктор, а когда - деструктор?
/*
	{
		Rect r1;
		Rect*	pR = new Rect(1,2,1,2);	
		{
			Rect r2(r1);
			Rect arRect[2];
			for(int i=0; i<3; i++)
			{
				static Rect r3 (i,i,i,i) ;
				Rect r4(*pR);
				Rect r5(i,i,i,i);
			}
		}
		delete pR;	
		stop
	}
*/
 
	//Задание 6.Конструктор + деструктор = функциональное
	// замыкание. Класс MyString
	// Посредством конструктора (конструкторов) и деструктора обеспечьте
	//корректные инициализацию и деактивацию объекта
	//C помощью остановов определите когда происходит
	//захват и освобождение памяти для строки-члена класса
/*
	{
		MyString	str("It's my string!");
		std::cout << str.len() << std::endl;

		//Создайте метод GetString(), который обеспечит доступ к хранящейся строке.
		//С помощью cout и метода GetString() распечатайте строку объекта str
		//Замечание: подумайте, как следует корректно реализовать метод GetString().
		std::cout << str.print() << std::endl;
		str.GetString();
		//...
	}

	stop
*/

	//6a. Раскомментируйте следующий фрагмент. Подумайте - какие
	//неприятности Вас ожидают. Попробуйте исправить положение (как?)
/*		{
			MyString str1("The first string!");
			MyString str2 = str1;
			str2.GetString();
			MyString str3("3335555555555555555555555555555");
			str2 = str3;
			str2.GetString();
		}
		stop
*/
	//6б. Реализуйте метод SetNewString, который будет заменять строку
	// на новую
/*
{
	MyString str("old string");
	str.SetNewString("new string11111");
	str.GetString();
}
*/

	//6г. Создайте глобальную функцию, которая будет принимать любое
	//количество указателей на строки, а возвращать объект MyString,
	//в котором строка будет конкатенацией параметров

	MyString s1("hello ");
	MyString s2("world");
	MyString str = Concatenate(s1.print(), s2.print(), "!"); //не работает!!!
	str.PrintString();


	//Задание 7.Массив объектов класса.
/*
{
	//Объявите и проинициализируйте массив ar из объектов
	// типа MyString. Например:
	//Как задать размерность? N=3
	const std::size_t N = 5;
	MyString arstr[N] = { MyString("str1"),MyString("str2"),MyString("str3") };

	//Проверка - печать строк-членов класса

	for (std::size_t i = 0; i < N; i++)
		arstr[i].GetString();
	char c;
	std::cin >> c;

	//Увеличьте размер массива, не изменяя список инициализаторов:
	//N=5???



	//Объявите и проинициализируйте массив объектов	типа Rect.
	
	const std::size_t M = 2;
	Rect arrect[M] = { {},{} };

	}
	stop
*/

	//Задание 8.Массив указателей на объекты класса.
/*
	{
	//Объявите и проинициализируйте массив arPtr из трех 
	//указателей на объекты типа MyString.
	std::size_t M = 3;
	MyString* arPtr[5] = { new MyString("sdfsdf"),new MyString(), new MyString() };// new MyString*[M];
	/*for (std::size_t i = 0; i < M; i++)
		arPtr[i] = new MyString{ "new string "};*/
/*
	//Печать строк-членов класса
	for (std::size_t i = 0; i < M; i++)
	{
		if (arPtr[i] != nullptr)
		{
			arPtr[i]->PrintString();
			delete arPtr[i];
		}
	}
  
	}
	stop

*/
	//Задание 9.  Решите с помощью классов следующую задачу:
	//даны две бочки известного объема. В одной бочке в начальный момент
	//времени содержится спирт (96%), в другой – вода.
	//Кружкой емкостью 1л переливаем итеративно содержимое из одной бочки
	//в другую следующим способом: на каждой итерации
	//зачерпнули из первой бочки -> вылили во вторую
	//зачерпнули из второй бочки -> вылили в первую.
	//Требуется определить номер итерации, на которой концентрация спирта в
	//первой бочке станет меньше 50%.
/*
	Bochka spirt(100, 96, "spirt");
	Bochka water(100, 0, "water");
	std::size_t count = 0;
	while(spirt.Con() > 50)
		{
			spirt.Pereliv(water); //или spirt.Pereliv(water, объем_кружки);
			std::cout << spirt.Con() << std::endl;
			water.Pereliv(spirt); // аналогично
			count++;
		}
	std::cout << "iterations " << count << std::endl;
*/
//159 итераций - правильный ответ
//X = 100NP / M — 100P
//Где N – изначальная крепость спирта;
//M – процент конечного(требуемого раствора);
//P — коэффициент(объем изначального раствора в миллилитрах разделить на 100);
//Х — количество мл воды, которые следует добавить к изначальному раствору.

	char c;
	std::cin >> c;
return 0;
}//end_main

